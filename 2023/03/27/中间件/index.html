


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  中间件 |    white.</title>
  <meta name="description" content="A minimalist theme for hexo.">
  <!-- 标签页图标 -->
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          white.
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              HOME
            </li>
          </a>
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              BLOG
            </li>
          </a>
        
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        white.
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>HOME</span>
      </div>
    </a>
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>BLOG</span>
      </div>
    </a>
  
  
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">中间件</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">Mar 27 2023</div>
      
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h2 id="redis是单线程还是多线程？"><a href="#redis是单线程还是多线程？" class="headerlink" title="redis是单线程还是多线程？"></a>redis是单线程还是多线程？</h2><ul>
<li>redis 4 之前完全单线程</li>
<li>redis 4 引入多线程用于后台处理</li>
<li>redis 6 中，多线程主要用于网络 I&#x2F;O 阶段，也就是接收命令和写回结果阶段</li>
</ul>
<h2 id="为什么-Redis-是单线程？"><a href="#为什么-Redis-是单线程？" class="headerlink" title="为什么 Redis 是单线程？"></a>为什么 Redis 是单线程？</h2><p>因为 redis 是完全基于内存操作的，通常情况下CPU不会是redis的瓶颈，redis 的瓶颈最有可能是机器内存的大小或者网络带宽。</p>
<h2 id="redis为什么快"><a href="#redis为什么快" class="headerlink" title="redis为什么快"></a>redis为什么快</h2><ul>
<li>基于内存操作</li>
<li>IO多路复用</li>
<li>对数据结构进行了优化，简单动态字符串、压缩列表等</li>
<li>单线程可以避免不必要的上下文切换和竞争条件，减少了这方面的性能消耗</li>
</ul>
<h2 id="Redis的数据结构有："><a href="#Redis的数据结构有：" class="headerlink" title="Redis的数据结构有："></a>Redis的数据结构有：</h2><ol>
<li>字符串：可以⽤来做最简单的数据缓存，可以缓存某个简单的字符串，也可以缓存某个json格式的字符<br>串，Redis分布式锁的实现就利⽤了这种数据结构，还包括可以实现计数器、Session共享、分布式ID</li>
<li>哈希表：可以⽤来存储⼀些key-value对，更适合⽤来存储对象</li>
<li>列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使⽤，可以⽤来缓存类似微信<br>公众号、微博等消息流数据</li>
<li>集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进⾏交集、并集、差集操作，从⽽<br>可以实现类似，我和某⼈共同关注的⼈、朋友圈点赞等功能</li>
<li>有序集合：集合是⽆序的，有序集合可以设置顺序，可以⽤来实现排⾏榜功能</li>
</ol>
<h2 id="Redis提供了三种集群策略："><a href="#Redis提供了三种集群策略：" class="headerlink" title="Redis提供了三种集群策略："></a>Redis提供了三种集群策略：</h2><ol>
<li>主从模式：这种模式⽐较简单，主库可以读写，并且会和从库进⾏数据同步，这种模式下，客户端直接连主库或某个从库，但是但主库或从库宕机后，客户端需要⼿动修改IP，另外，这种模式也⽐较难进⾏扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能⽀持特⼤数据量</li>
<li>哨兵模式：这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕机，然后在从库中选择⼀个库作为进的主库，另外哨兵也可以做集群，从⽽可以保证但某⼀个哨兵节点宕机后，还有其他哨兵节点可以继续⼯作，这种模式可以⽐较好的保证Redis集群的⾼可⽤，但是仍然不能很好的解决Redis的容量上限问题。</li>
<li>Cluster模式：Cluster模式是⽤得⽐较多的模式，它⽀持多主多从，这种模式会按照key进⾏槽位的分配，可以使得不同的key分散到不同的主节点上，利⽤这种模式可以使得整个集群⽀持更⼤的数据容量，同时每个主节点可以拥有⾃⼰的多个从节点，如果该主节点宕机，会从它的从节点中选举⼀个新的主节点。</li>
<li>对于这三种模式，如果Redis要存的数据量不⼤，可以选择哨兵模式，如果Redis要存的数据量⼤，并且需要持续的扩容，那么选择Cluster模式。</li>
</ol>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul>
<li>rabbitmq</li>
<li>rocketmq</li>
<li>kafka</li>
<li>RabbitMQ 采用队列模型，RocketMQ和Kafka 采用发布&#x2F;订阅模型</li>
</ul>
<h2 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h2><ul>
<li>解耦<ul>
<li>使用消息队列可以将应用程序组件之间的通信解耦合，从而降低它们之间的依赖性。这使得应用程序更加灵活、可维护和可扩展。</li>
<li>可以在多个系统之间进行解耦，将原本通过网络之间的调用的方式改为使用MQ进行消息的异步通讯，只要该操作不是需要同步的，就可以改为使用MQ进行不同系统之间的联系，这样项目之间不会存在耦合，系统之间不会产生太大的影响，就算一个系统挂了，也只是消息挤压在MQ里面没人进行消费而已，不会对其他的系统产生影响。</li>
</ul>
</li>
<li>异步<ul>
<li>使用消息队列可以实现应用程序组件之间的异步通信。发送方将消息放入队列中，接收方可以在方便的时候从队列中获取消息进行处理，而不需要立即响应请求。</li>
<li>有些步骤之间不需要同步完成，比如客户去创建了一个订单，还要去客户轨迹系统添加一条轨迹、去库存系统更新库存、去客户系统修改客户的状态等等。这样如果这个系统都直接进行调用，那么将会产生大量的时间。可加快系统的访问速度，提供更好的客户体验。</li>
</ul>
</li>
<li>削峰<ul>
<li>当流量高峰时，可以将消息放入队列中进行处理，从而避免系统崩溃。而当流量较小时，可以从队列中获取消息进行处理，从而提高系统效率。</li>
<li>到了某个抢购活动时间，系统并发访问了剧增，比如达到了每秒5000个并发请求，而我们的系统每秒只能处理2000个请求，那么由于流量太大，我们的系统、数据库可能就会崩溃。这时如果使用MQ进行流量削峰，将用户的大量消息直接放到MQ里面，然后我们的系统去按自己的最大消费能力去消费这些消息，就可以保证系统的稳定</li>
</ul>
</li>
</ul>
<hr>
<p>一般我们称发送消息方为生产者 Producer，接受消费消息方为消费者Consumer，消息队列服务端为Broker<br>
        <span class="lazyload-img-span">
        <img   
           data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/15/1735186a1861d6c0~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" >
        </sapn>
      </p>
<h2 id="如何保证消息队列的高可用"><a href="#如何保证消息队列的高可用" class="headerlink" title="如何保证消息队列的高可用"></a>如何保证消息队列的高可用</h2><ul>
<li>集群部署：使用多个消息队列实例构建一个集群，这样即使某个实例发生故障，其他实例仍然可以继续工作，保证服务的可用性</li>
<li>主从复制：通过主从复制机制，在多个节点之间复制消息队列的数据，从而实现数据的备份和容错。</li>
<li>负载均衡：通过负载均衡器将请求分发到多个消息队列实例上，从而避免单个实例的过载和故障。</li>
<li>持久化存储：使用持久化存储将消息队列中的数据存储到磁盘上，以保证数据的可靠性和持久性。如果一个实例故障，数据仍然可以恢复。</li>
</ul>
<h2 id="如何保证消息不重复消费"><a href="#如何保证消息不重复消费" class="headerlink" title="如何保证消息不重复消费"></a>如何保证消息不重复消费</h2><ul>
<li>幂等性：同样的参数多次调用同一个接口和调用一次产生的结果是一致的。<ul>
<li>前置条件判断:版本号</li>
<li>数据库的约束例如唯一键</li>
<li>记录关键的key，比如处理订单这种，记录订单ID，假如有重复的消息过来，先判断下这个ID是否已经被处理过了，如果没处理再进行下一步。</li>
<li>局唯一ID</li>
</ul>
</li>
</ul>
<h2 id="如何保证数据不丢失？"><a href="#如何保证数据不丢失？" class="headerlink" title="如何保证数据不丢失？"></a>如何保证数据不丢失？</h2><ol>
<li>生产者需要处理好Broker的响应，出错情况下利用重试、报警等手段。</li>
<li>Broker需要控制响应的时机，单机情况下是消息刷盘后返回响应，集群多副本情况下，即发送至两个副本及以上的情况下再返回响应。</li>
<li>消费者需要在执行完真正的业务逻辑之后再返回响应给Broker。</li>
</ol>
<ul>
<li>持久化存储：将消息队列中的数据存储到磁盘上，从而保证数据的持久性和可靠性。当消息队列中的数据还未被消费时，可以将数据存储到消息队列的持久化存储中；当数据被消费时，可以将消费完成的数据同步到数据库等其他存储系统中，以保证数据的可靠性。</li>
</ul>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/v123411739/article/details/116109674">https://blog.csdn.net/v123411739/article/details/116109674</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903849086418957">https://juejin.cn/post/6844903849086418957</a></p>

        <!-- 分类文章 -->
        
      </div>
      <div class="post-content-inner-space">
        
          <div class="space-toc-main animate__animated  animate__fadeInUp">
            <ol class="space-toc"><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#Redis"><span class="space-toc-text">Redis</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="space-toc-text">redis是单线程还是多线程？</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Redis-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="space-toc-text">为什么 Redis 是单线程？</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="space-toc-text">redis为什么快</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%EF%BC%9A"><span class="space-toc-text">Redis的数据结构有：</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#Redis%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="space-toc-text">Redis提供了三种集群策略：</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="space-toc-text">消息队列</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="space-toc-text">为什么使用消息队列</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="space-toc-text">如何保证消息队列的高可用</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="space-toc-text">如何保证消息不重复消费</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="space-toc-text">如何保证数据不丢失？</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#Source"><span class="space-toc-text">Source</span></a></li></ol>
           </div>
        
      </div>
   </div>
    <!-- 评论 -->
    
    <div class="bottom-comments-outer">
      <div class="bottom-comments-inner">
        <!-- valine -->
        
        <!-- Gitalk -->
        
        <!-- livere -->
        
        </div>
      </div>
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>Power by <a target="_blank" rel="noopener" href="http://hexo.io/">Hexo</a> Theme by <a target="_blank" rel="noopener" href="https://github.com/FuShaoLei/hexo-theme-white">White</a></p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://github.com/CHENZhoujing" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:zhoujingchen1@gmail.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



</body>
</html>
