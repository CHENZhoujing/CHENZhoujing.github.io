


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  JVM |    white.</title>
  <meta name="description" content="A minimalist theme for hexo.">
  <!-- 标签页图标 -->
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          white.
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              HOME
            </li>
          </a>
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              BLOG
            </li>
          </a>
        
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        white.
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>HOME</span>
      </div>
    </a>
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>BLOG</span>
      </div>
    </a>
  
  
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">JVM</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">Apr 09 2023</div>
      
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <h2 id="JVM包含哪几部分？"><a href="#JVM包含哪几部分？" class="headerlink" title="JVM包含哪几部分？"></a>JVM包含哪几部分？</h2><ul>
<li>Class Loader 类加载系统<ul>
<li>负责加载字节码文件即class文件。</li>
</ul>
</li>
<li>Runtime Data Area 运行时数据区<ul>
<li>分为五部分： Stack, Heap, Method Area, PC Register, Native Method Stack. 虚拟机栈，堆，方法区，程序计数器，本地方法栈。</li>
</ul>
</li>
<li>Execution engine 执行引擎<ul>
<li>Class文件被加载后，会把指令和数据信息存入内存中，执行引擎负责把这些命令解释给操作系统-&gt;将JVM指令集翻译为操作系统指令集。</li>
</ul>
</li>
<li>Native interface 本地库接口<ul>
<li>负责调用不同语言的接口给Java用，他会在本地方法区记录对应的本地方法，然后调用该方法时就通过执行引擎加载对应的本地lib</li>
</ul>
</li>
</ul>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690687338/9602C6323C6B86C4EDA164DB052D8420" >
        </sapn>
      </p>
<h2 id="介绍一下类加载的过程"><a href="#介绍一下类加载的过程" class="headerlink" title="介绍一下类加载的过程"></a>介绍一下类加载的过程</h2><p>三个阶段：加载，链接，初始化</p>
<ul>
<li>加载：类加载器把字节码文件从硬盘加载到JVM内存中，将字节码文件转换为内部的数据结构，并在jvm堆内存中创建一个类对象。JVM还会为类分配一块内存，用于存储静态变量和方法等信息。</li>
<li>链接：jvm将类和其他类进行链接，分为三个子阶段：<ul>
<li>验证字节码文件的语法和结构是否正确。</li>
<li>JVM为类的静态变量分配内存，并赋默认值。</li>
<li>将类中的引用转换为直接引用，以便使用。</li>
</ul>
</li>
<li>初始化：JVM执行类的静态代码块和静态变量的初始化。如果类有父类，先初始化父类，再初始化子类。<br>JVM可以在程序运行过程中根据需要动态加载和链接类，从而增加程序的灵活性和扩展性。</li>
</ul>
<h2 id="什么是类加载系统？"><a href="#什么是类加载系统？" class="headerlink" title="什么是类加载系统？"></a>什么是类加载系统？</h2><p>Java的类加载系统负责将字节码文件加载到jvm内存中，进行链接和初始化。它是由三个主要的类加载器组成的层次系统，每个类加载器负责加载一组类。</p>
<ol>
<li>引导类加载器 Bootstrap ClassLoader<ul>
<li>引导类加载器时jvm最顶层的加载器，由C++实现，它负责加载jvm运行所需要的类，包括核心类库和	jvm配置文件。其它所有加载器都是它的字类加载器。</li>
</ul>
</li>
<li>扩展类加载器 Extension ClassLoader<ul>
<li>扩展类加载器是二级类加载器，它负责加载java扩展库，由java实现。</li>
</ul>
</li>
<li>应用程序类加载器 Application ClassLoader<ul>
<li>应用程序加载器时三级类加载器，它负责加载应用程序的类，由java实现，通常是我们编写java程序	的默认类加载器。</li>
</ul>
</li>
<li>自定义加载器<ul>
<li>用来加载特定的类或者资源文件，通过继承ClassLoader类，并重写findClass()方法来实现类加载的逻辑。</li>
</ul>
</li>
</ol>
<h2 id="什么是双亲委派？"><a href="#什么是双亲委派？" class="headerlink" title="什么是双亲委派？"></a>什么是双亲委派？</h2><ul>
<li>双亲委派是java类加载机制的一种重要方式，最初是由sun公司的java工程师实现的，其实它应该叫父委派，这是一个翻译错误，原文里parent指父类。</li>
<li>基本思想：当一个类加载器需要加载一个类时，它首先请求委派给他的父类加载器进行加载，当它的父类加载器不能加载时，这个类加载器再自己加载。</li>
<li>优点：<ol>
<li>避免重复加载：当一个类被加载时，它会被委派给父类加载器进行加载，如果父类加载器已经加载，子类加载器就不需要继续加载该类了。避免重复加载，提高类加载效率。</li>
<li>提高安全性：防止恶意代码注入，如果恶意代码想要被加载，它必须绕过所有的父类加载器，直接由自定义类加载器加载。</li>
<li>统一管理：java的类加载器按照层次结构来组织，每个类都有父类，除了最顶层的引导类加载器。可以让java的类加载器形成一个统一的管理体系，使得Java的类加载机制更加灵活和扩展。</li>
</ol>
</li>
</ul>
<h2 id="介绍一下Java的垃圾回收机制"><a href="#介绍一下Java的垃圾回收机制" class="headerlink" title="介绍一下Java的垃圾回收机制"></a>介绍一下Java的垃圾回收机制</h2><pre><code>引用计数法
可达性分析算法
</code></pre>
<ul>
<li>引用计数法：在对象中添加一个引用计数器，每当有一个地方使用它，计数器就加一，引用失效时，计数器减一。当计数器为零时则可以回收。<br>Java中一般不使用，因为会有类似于循环引用的问题。但Python使用引用计数法进行垃圾回收。通过使用标记清除算法解决循环引用。它会有两次遍历，第一次会把所有的对象的gc_ref引用数减一，把所有为0的对象加入到清除链表内。第二次遍历则是碰到所有计数不为0的对象，从它出发递归到所有可达的节点，把这些节点从清除链表内移动回来。两次完成之后就可以清理所有清除链表内的对象。</li>
<li>可达性分析算法：从GC roots set做为启始节点集合，从这些节点出发，根据引用关系向下搜索。所有其他的对象都是不可达的也就是可以回收的对象。</li>
</ul>
<h2 id="垃圾回收算法有哪些？"><a href="#垃圾回收算法有哪些？" class="headerlink" title="垃圾回收算法有哪些？"></a>垃圾回收算法有哪些？</h2><pre><code>标记-清除
标记-复制
标记-整理
分代收集
</code></pre>
<ul>
<li>标记-清除：先标记出所有需要被回收的对象，然后在标记完成之后统一回收掉所有被标记对象。<ul>
<li>缺点：1效率不高 2产生很多内存碎片，分配大对象时，在没有足够空间时会提前触发垃圾回收。</li>
</ul>
</li>
<li>标记-复制：将内存按照容量分成大小相等的两块，每次只使用一半，当这块内存用完了，就把还存活的对象复制到另一半，再把已使用的内存一次清理掉。<ul>
<li>优点：不用考虑内存碎片，按序分配内存即可</li>
<li>缺点：内存缩减为一半</li>
</ul>
</li>
<li>标记-整理：标记出所有被回收的对象，使所有存活的对象像一端移动，直接清理掉边界以外的内存。<ul>
<li>优点：解决标记清除算法的内存碎片问题，解决复制算法复制效率低，空间利用率低等问题。</li>
</ul>
</li>
</ul>
<h2 id="垃圾收集器有哪些？"><a href="#垃圾收集器有哪些？" class="headerlink" title="垃圾收集器有哪些？"></a>垃圾收集器有哪些？</h2><ul>
<li>Serial 收集器<ul>
<li>使用单线程，当垃圾收集器运行时，会停止应用程序（通常称为“stop the world”事件）。</li>
</ul>
</li>
<li>Parallel 收集器<ul>
<li>使用多线程，当垃圾收集器运行时，会停止应用程序（通常称为“stop the world”事件）。</li>
</ul>
</li>
<li>G1 收集器</li>
<li>ZGC 收集器<ul>
<li>停顿时间不超过10ms；</li>
<li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</li>
<li>支持8MB~4TB级别的堆（未来支持16TB）</li>
<li>鼓励新建对象</li>
</ul>
</li>
</ul>
<h2 id="AOP：动态代理和字节码增强"><a href="#AOP：动态代理和字节码增强" class="headerlink" title="AOP：动态代理和字节码增强"></a>AOP：动态代理和字节码增强</h2><ul>
<li>动态代理：动态代理是指在运行时动态生成一个代理对象，用于代替真实对象进行某些操作。</li>
<li>字节码增强：字节码增强是指通过修改目标类的字节码，来实现横切关注点的功能。</li>
<li>动态增强：使用动态增强技术，创建代理类，代理类有自己的唯一名称，代理类实现接口类或者继承于原始类，其实就是生成了一个新的类。<ul>
<li>JDK动态代理是Java语言自带的一种动态代理实现方式。它通过反射机制动态地创建一个代理类，该代理类实现了指定的一组接口，并在实现接口的方法中调用委托类的相应方法。</li>
<li>Cglib框架动态代理是一个基于ASM字节码技术的代理实现方式。它通过生成被代理类的子类来实现代理。由于Cglib是基于字节码的，所以它可以代理没有实现接口的类。</li>
</ul>
</li>
<li>静态增强：这种情况也就是上面介绍的AspectJ技术，在运行前就对class做了增强处理，所以加载方式和普通类的加载方式没有任何区别，在运行期间可能都不知道对class文件做了增强。<ul>
<li>通常使用AspectJ框架来实现。</li>
<li>在编译时增强中，AspectJ会根据切面的定义，生成一些辅助类和方法，然后将它们织入到目标类的字节码中。这些辅助类和方法会与目标类的代码一起编译成一个完整的类文件，因此在运行时，目标类的字节码已经被增强了。</li>
</ul>
</li>
<li>可以使用JDK动态代理来代理实现了接口的目标对象，使用Cglib框架动态代理来代理没有实现接口的目标对象，再结合字节码增强来实现更加复杂的横切关注点。</li>
</ul>
<h2 id="Jdk1-7到Jdk1-8-java虚拟机发⽣了什么变化"><a href="#Jdk1-7到Jdk1-8-java虚拟机发⽣了什么变化" class="headerlink" title="Jdk1.7到Jdk1.8 java虚拟机发⽣了什么变化?"></a>Jdk1.7到Jdk1.8 java虚拟机发⽣了什么变化?</h2><ul>
<li>jdk1.7存在永久代，存在于虚拟机内部，jdk1.8变成元空间，元空间存在于本地内存空间。不管是永久代还是元空间，他们都是⽅法区的具体实现。</li>
<li>如⽅法区所存储的类信息通常是⽐较难确定的，所以对于⽅法区的⼤⼩是⽐较难指定的，太⼩了容易出现⽅法区溢出，太⼤了⼜会占⽤了太多虚拟机的内存空间，⽽转移到本地内存后则不会影响虚拟机所占⽤的内存。</li>
<li>Java 应用程序使用元空间代替永久代，可以更好地管理内存，并且减少 OutOfMemoryError 错误的发生。</li>
</ul>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tuyang1129/p/12878549.html">https://www.cnblogs.com/tuyang1129/p/12878549.html</a>  </p>

        <!-- 分类文章 -->
        
      </div>
      <div class="post-content-inner-space">
        
          <div class="space-toc-main animate__animated  animate__fadeInUp">
            <ol class="space-toc"><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#JVM%E5%8C%85%E5%90%AB%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86%EF%BC%9F"><span class="space-toc-text">JVM包含哪几部分？</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="space-toc-text">介绍一下类加载的过程</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="space-toc-text">什么是类加载系统？</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%EF%BC%9F"><span class="space-toc-text">什么是双亲委派？</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BJava%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="space-toc-text">介绍一下Java的垃圾回收机制</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="space-toc-text">垃圾回收算法有哪些？</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="space-toc-text">垃圾收集器有哪些？</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#AOP%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA"><span class="space-toc-text">AOP：动态代理和字节码增强</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#Jdk1-7%E5%88%B0Jdk1-8-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%91%E2%BD%A3%E4%BA%86%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96"><span class="space-toc-text">Jdk1.7到Jdk1.8 java虚拟机发⽣了什么变化?</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#Source"><span class="space-toc-text">Source</span></a></li></ol>
           </div>
        
      </div>
   </div>
    <!-- 评论 -->
    
    <div class="bottom-comments-outer">
      <div class="bottom-comments-inner">
        <!-- valine -->
        
        <!-- Gitalk -->
        
        <!-- livere -->
        
        </div>
      </div>
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>Power by <a target="_blank" rel="noopener" href="http://hexo.io/">Hexo</a> Theme by <a target="_blank" rel="noopener" href="https://github.com/FuShaoLei/hexo-theme-white">White</a></p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://github.com/CHENZhoujing" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:zhoujingchen1@gmail.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



</body>
</html>
